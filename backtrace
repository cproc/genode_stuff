#! /usr/bin/perl -W

# Based on 'backtrace' from the Fiasco.OC distribution (GPLv2)

use Math::BigInt;
use strict;

my %sym_tab = (new Math::BigInt(0) => "ERRRRRRROR");
my $sections = "BdDdTtVvWwuU";
my %sec_tab;
my %img_tab;
my %base_tab;
my %line_tab;

my @sorted_sym_tab_keys;
my $min_addr;
my $max_addr;

my %test;

sub as_hex($)
{
  my $i = shift;
  my $h = substr $i->as_hex(), 2;
  $h = ('0' x (16-length($h))) . $h;
  return $h;
}

if (!defined $ARGV[0])
{
  print "$0 image(s)\n";
  print " input is read from stdin\n";
  exit 1;
}

my $nm = '/usr/local/genode-gcc/bin/genode-x86-nm';
$nm = '/usr/local/genode-gcc/bin/genode-arm-nm' if !(system("file -L $ARGV[0] | grep -qw ARM") >> 8);
$nm = "$ENV{'SYSTEM_TARGET'}$nm" if defined $ENV{"SYSTEM_TARGET"};

my $addr2line = '/usr/local/genode-gcc/bin/genode-x86-addr2line';
$addr2line = '/usr/local/genode-gcc/bin/genode-arm-addr2line' if !(system("file -L $ARGV[0] | grep -qw ARM") >> 8);
$addr2line = "$ENV{'SYSTEM_TARGET'}$addr2line" if defined $ENV{"SYSTEM_TARGET"};

sub scan_image
{
    my $img = shift;
    my $base = shift;

    foreach my $l (split('\n', qx{$nm $img | c++filt}))
      {
	if ($l =~ /^([0-9a-fA-F]*)\s+([$sections])\s+(.*)$/)
	  {
	    my ($addr, $sec, $sym) = ($base + new Math::BigInt("0x$1"), $2, $3);
	    if (defined $addr && ref $addr && !$addr->is_nan())
	      {
		$img_tab{as_hex($addr)} = $img;
		$base_tab{as_hex($addr)} = $base;
		$sym_tab{as_hex($addr)} = $sym;
		$sec_tab{as_hex($addr)} = $sec;
	      }
	  }
      }

	@sorted_sym_tab_keys = sort keys %sym_tab;
	$min_addr = $sorted_sym_tab_keys[0];
	$max_addr = $sorted_sym_tab_keys[@sorted_sym_tab_keys - 1];

	$img =~ s/.*\/(.*)/$1/;
	print "Scanned image \'$img\'\n";
}

while (@ARGV)
{
	my $img = shift;
	scan_image($img, new Math::BigInt("0x0"));
}

#print "Scanning image done, proceed.\n";

sub find_sym($)
{
  my $addr = as_hex(shift);
  my $hit = '0';

  return new Math::BigInt(0)
    if $addr lt $min_addr or $addr gt $max_addr;

  foreach my $s (@sorted_sym_tab_keys)
  {
    if ($s gt $addr)
    {
      return new Math::BigInt("0x$hit");
    }

    $hit = $s;
  }

  return new Math::BigInt(0);
}

sub print_func_with_location(@)
{
  my $addr = new Math::BigInt("0x".shift);
  my $count = shift;
  my $hit  = find_sym($addr);
  my $offset = $addr-$hit;
  my $o = $hit->as_hex();

  if ($hit) {
      my $img = $img_tab{as_hex($hit)};
      my $img_name = $img;
      $img_name =~ s/.*\/(.*)/$1/;
      my $local_addr = $addr - $base_tab{as_hex($hit)};
      my $local_hit = $hit - $base_tab{as_hex($hit)};
      my $local_addr_as_hex = $local_addr->as_hex();
      my $line = qx{$addr2line -e $img $local_addr_as_hex};

  	  printf " %7s %18s %18s  %-30s  %s(%s) + %6s = %s\n",
	 	 $count, $addr->as_hex(), $local_addr->as_hex(), $img_name, $sym_tab{as_hex($hit)}, $sec_tab{as_hex($hit)},
	 	 $offset->as_hex(), $local_hit->as_hex();
	  printf "                                                                                                      in file %s", $line;
  } else {
	  printf " %7s %18s                  ?\n",
	     $count, $addr->as_hex();
  }
}

sub print_func($)
{
  my $addr = new Math::BigInt("0x".shift);
  my $hit  = find_sym($addr);

  if ($hit) {
      my $img = $img_tab{as_hex($hit)};
      my $img_name = $img;
      $img_name =~ s/.*\/(.*)/$1/;

  	  printf "%-32s %s\n", $img_name, $sym_tab{as_hex($hit)};
  } else {
	  printf " %18s                  ?\n",
	     $addr->as_hex();
  }
}

my $last_f = 0;
while (<>)
{
  if (/^\s*([0-9]+)\s+([0-9a-f]+)/i)
  {
    print_func_with_location($2, $1);
  }
  elsif (/^([0-9a-f]+)$/i)
  {
	print_func($1);
  }
  elsif (/^\[.*\]   0x([0-9a-f]*).*?: (.*)/) # Genode shared library info
  {
	my $base = new Math::BigInt("0x$1");
	my $img = $2;

	if ($img eq 'ld.lib.so') {
		$base = 0;
	}

	scan_image($img, $base);
  }
}
